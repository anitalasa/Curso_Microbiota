[
  {
    "objectID": "AnalisisBacterias.html",
    "href": "AnalisisBacterias.html",
    "title": "Analisis comunidades bacterianas",
    "section": "",
    "text": "En este manual encontrareis todas las directrices para el análisis de las comunidades bacterianas de la endosfera de dos tipos de pinos: pinos con síntomas de decaimiento forestal (SIGLAS) y pinos asintomáticos (SIGLAS). Cada grupo de muestras está formado por 12 réplicas."
  },
  {
    "objectID": "AnalisisBacterias.html#anális-estadístico",
    "href": "AnalisisBacterias.html#anális-estadístico",
    "title": "Analisis comunidades bacterianas",
    "section": "6.1 Anális estadístico",
    "text": "6.1 Anális estadístico\nAplicaremos tests de estadística univariante para cada uno de los índices. Compararemos si los índices de los dos grupos de muestras son iguales o no. Para este análisis, utilizaremos un nivel de confianza de = 95%, por lo tomaremos un alpha = 0.05.\nPara ello, primero debemos conocer el tipo de distribución de los datos, y elegir el mejor test a aplicar.\n\n6.1.1 Comprobación de premisas\nComenzamos aplicando el test de Levene con el que evaluamos si la varianza de los dos grupos a comparar es la misma o no (homocedasticidad). H0: los dos grupos de muestran son homocedásticos.\n\nlevene = levene.test.alpha(indices, 4, \"status\") \n#argumentos: \n#tabla de indices calculados replica a replica (NO confundir con la tabla de publicaciones)\n#número de indices a testar\n#nombre de la variable de agrupacion (tiene que coincidir exactamente con el nombre incluido en la tabla de indices)\n\nObservamos que para ningún índice obtenemos un pvalor superior al umbral alpha seleccionado, luego nos encontramos ante datos homocedásticos\nComprobamos si los datos se distribuyen de forma normal [Gaussiana], mediante el test de Shapiro-Wilks.\n\nshapiro = Shapiro(indices, 4, \"status\")\nshapiro\n\nVemos que tan solo el índice de riqueza se distribuye de forma normal. Nos encontramos pues ante variables homocedásticas de distribución no-normal (excepto la riqueza observada).\nLos test estadísticos univariantes son muy sensibles a la heterocedasticidad, pero no tanto a la distribución no-normal de los datos. Puesto que todas nuestras variables son homocedásticas, comprobemos si los datos se alejan mucho de una distribución normal. Para ello, construiremos gráficos de tipo Q-Q (quantile-quantile plot), que nos comparan la distribución de nuestros datos vs una normal teórica:\n\nqq_invsimpson=ggqqplot(indices, \"InvSimpson\", ggtheme = theme_bw())\nqq_sha=ggqqplot(indices, \"Shannon\", ggtheme = theme_bw())\nqq_pielou=ggqqplot(indices, \"Pielou\", ggtheme = theme_bw())\n\nEn las Figuras 3-5 podemos ver la distribución de las variables. Apreciamos que no se separan mucho de la normalidad teórica, por lo que aplicaremos test univariantes paramétricos.\n  \n\n\n6.1.2 Aplicación de test estadísticos\nPuesto que queremos comparar dos grupos de muestras, y teniendo en cuenta los comentarios realizados sobre la distribución de las muestras, aplicaremos el test t-Student a todos los índices. H0: no hay diferencias en la media de los dos grupos\n\ntstudent =Tukey.test(indices, 4, \"status\", balanced=F)# Incorpora un argumento más, 'balanced', de tipo booleriano. En este caso, puesto que tenemos un ligero desbalance en los datos, le decimos que FALSE\ntstudent\n\nEn la tabla de salida apreciamos que el pvalor en todos los casos es &lt; 0.05, por lo que rechazamos la hipótesis nula, determinando que la diversidad, riqueza y equidad de los árboles sanos y enfermos es significativamente diferente.\n\n\n\n\n\n\nImportant\n\n\n\nMUY IMPORTANTE: cada variable debe inspeccionarse y tratarse de forma independiente. En este caso, hemos detectado que casi todas las variables se distribuyen de la misma manera, por lo que hemos usado la función Tukey.test del paquete micro4all, que aplica el mismo test a todas las variables incluidas en nuestra table. Si cada una de nuestras variables tiene una distribución o características concretas (paramétrica, heterocedástica, no-paramétrica), debemos aplicar el test más adecuado para cada variable. En ese caso, no es recomendable emplear las funciones incluidas en el paquete micro4all, sino las incluidas en el paquete rstatix, tratando cada una de forma independiente.\n\n\n\n\n\n\n\n\nImportant\n\n\n\nEs importante tener en cuenta que el hecho de que tengamos un pvalor muy bajo NO significa que las diferencias observadas sean grandes. Para obtener información sobre la magnitud de las diferencias, calculamos el tamaño del efecto, que, al tratarse de comparaciones de dos grupos, debemos calcular la d de Cohen (Cohen’s d).\n\n\n\n#hacemos un bucle for sobre la funcion cohens_d \ncohen =data.frame()\ncolumnas =names(indices)[1:4]  #que coja los nombres de las 1as 4 columnas donde estan los indices\n\nfor (i in columnas) {\n  d = cohens_d(as.formula(paste(i, \"~ status\")), data = indices)$effsize\n  mag = cohens_d(as.formula(paste(i, \"~ status\")), data = indices)$magnitude\n  cohen = rbind(cohen, data.frame(variable = i, cohen_d = d, magnitude=mag))\n}\ncohen#nos devuelve la variable y el tamaño del efecto. \n\nEl tamaño del efecto se clasifica en categorías en función del valor de la d de Cohen:\nsi d &lt; 0.2 –&gt; no efecto si 0.21 &lt; d &lt; 0.49 –&gt; efecto pequeño si 0.5 &lt; d &lt; 0.8 –&gt; efecto moderado si d &gt; 0.8 –&gt; efecto grande\nPor lo tanto, para todos nuestros indices, las diferencias observadas podemos clasificarlas como ‘Grandes’\n\n\n6.1.3 Representación gráfica\nLos valores de los índices en tablas son muy útiles pero, una imagen vale más que mil palabras. Se pueden hacer distintos tipos de gráficos, pero haremos boxplots ya que nos dan una idea de la dispersión de cada uno de los índices.\n\nalpha_plot_table=tidyr::pivot_longer(data = indices, names_to = \"Measure\", values_to = \"Value\", cols=c(Observed, Shannon, InvSimpson, Pielou))#esta funcion sirve para que tranforme la tabla y todos los valores de todos los índices estén en una sola columna, apilados.\n\nalpha_graphic=ggplot(data = alpha_plot_table, aes(x = status, y = Value)) +\n  facet_wrap(~factor(Measure, levels=c(\"Observed\", \"InvSimpson\",\"Shannon\", \"Pielou\")), scale = \"free\") + #generamos una grafica por índice\n  geom_boxplot()+\n  scale_x_discrete(breaks=c(\"healthy\",\"diseased\"), \n                   labels=c(\"Asymptomatic\",\"Symptomatic\")) +\n  aes(fill=status)+ \n  scale_fill_manual(values = c(\"healthy\"=\"green\",\"diseased\"=\"black\"),\n                  breaks=c(\"healthy\",\"diseased\"), \n                   labels=c(\"Asymptomatic\",\"Symptomatic\"),na.translate=FALSE) +\n  theme(legend.key.size = unit(1, 'cm')) +\n  ggtitle(expression(\"Endosphere (\" *italic(\"P. sylvestris\")* \")\"))+\n  theme(axis.text.x = element_text(size=13),\n        strip.text = element_text(size = 20),\n        axis.text.y = element_text(size=15), \n        axis.title.y=element_blank(),\n        axis.title.x=element_blank(),\n        plot.title = element_text(hjust = 0.5),\n        legend.position=\"bottom\",\n        legend.title = element_blank())\n\n#x11() #comentando x11() logramos que el grafico se vea en el visualizador de graficos, en el panel derecho --&gt;\nalpha_graphic"
  },
  {
    "objectID": "AnalisisBacterias.html#normalización-de-los-datos",
    "href": "AnalisisBacterias.html#normalización-de-los-datos",
    "title": "Analisis comunidades bacterianas",
    "section": "7.1 Normalización de los datos",
    "text": "7.1 Normalización de los datos\nNuestra tabla de ASVs original está constituida por el número de ocurrencias de cada ASV en cada muestra (número de secuencias de cada ASV). Podemos tener ASVs para los que se han detectado 5 secuencias, y otros representados por 5000 secuencias. Es necesario escalar los valores y transformarlos todos al mismo rango. Existen diferentes tipos de normalizaciones para evitar estos posibles sesgos, como la transformación logarítmica, o la normalización que aplica EdgeR. Emplearemos esta por su popularidad:\n\n#Lo primero es obtener nuevos objetos phyloseq normalizados\nASV_pruned=data.frame(otu_table(phy_pruned,taxa_are_rows = T))\nmt_pruned=data.frame(sample_data(phy_pruned))\ntax_pruned=data.frame(tax_table(phy_pruned))\ntree_pruned=phy_tree(phy_pruned)\n\n#Creamos un objeto DGE necesario para hacer la normalizacion\nedgeR = DGEList(counts = ASV_pruned, samples = mt_pruned, genes = tax_pruned)\n#Calculamos los factores de normalizacion para corregir la diferencia de profundidad de muestreo y los datos relativos\nedgeR = calcNormFactors(edgeR)\n#Extraemos la abundancia normalizada\nASV_pruned_norm = cpm(edgeR, normalized.lib.sizes=T, log=F)\n\n#Volvemos a crear un objeto phyloseq con los datos normalizados\nphy_ASV_norm=otu_table(as.data.frame(ASV_pruned_norm,row.names=F), taxa_are_rows = T)\nphy_taxonomy_norm=tax_table(as.matrix(tax_pruned))\nphy_metadata_norm=sample_data(mt_pruned)\n\n#Añadimos el nombre de los taxones\ntaxa_names(phy_ASV_norm)= taxa_names(phy_taxonomy_norm)\n#Comprobamos que sean identicos\nidentical(rownames(phy_ASV_norm), rownames(phy_taxonomy_norm))\n#Fusionamos todos los componentes del phyloseq\nnormalized_phyloseq = phyloseq(phy_ASV_norm,\n                               phy_taxonomy_norm,\n                               phy_metadata_norm,\n                               tree_pruned)"
  },
  {
    "objectID": "AnalisisBacterias.html#comparación-de-diversidad-beta-entre-grupos-de-muestras",
    "href": "AnalisisBacterias.html#comparación-de-diversidad-beta-entre-grupos-de-muestras",
    "title": "Analisis comunidades bacterianas",
    "section": "7.2 Comparación de diversidad beta entre grupos de muestras",
    "text": "7.2 Comparación de diversidad beta entre grupos de muestras\nAplicaremos técnicas de estadística multivariante tanto para comparar los grupos de muestras entre sí como para visualizar las diferencias entre ellos.\nLa versión multivariante del test de Levene (homocedasticidad) es el test PERMDISP2. El concepto es el mismo: probar la dispersión de todos los grupos de muestras (llamada betadispersión) es la misma. En este caso, tendremos muchas variables (la abundancia de cada ASV en cada una de las muestras).\nPor otro lado, para comparar si el centroide (concepto similar al de media en el espacio multivariante) de ambos grupos de muestras es el mismo, se emplea el test PERMANOVA, el cual no asume ningún tipo de distribución de los datos y es el equivalente multivariante al test univariante de ANOVA.\n\n\n\n\n\n\nImportant\n\n\n\nEn el caso multivariante, el test PERMANOVA NO es sensible a la heterocedasticidad si tenemos un diseño balanceado, por lo que en casos balanceados no se suele aplicar. Sin embargo, si tenemos un número diferente de réplicas en cada grupo de muestras (como en este ejercicio), y estas son heterocedásticas, el test PERMANOVA no es capaz de distinguir si las diferencias detectadas son debidas a diferencias reales en el centroide o en la dispersión de las muestras. Por consiguiente, en casos de diseño desbalanceado es esencial aplicar el test PERMDISP2\n\n\nPara poder comparar entre sí los grupos de muestras, ha de hacerse en base a una medida de distancia o disimilitud. Existen diferentes tipos de medidas de distancia o disimilitud (1-similitud), entre las cuales queremos destacar estas tres:\n-Disimilitud Bray-Curstis: tiene en cuenta la abundancia de las especies -Distancia Unweighted UniFrac: tiene en cuenta la distancia filogenética de las especies, pero NO su abundancia. -Distancia Weighted-UniFrac: tiene en cuenta tanto la distancia filogenética de las especies que componen los pares de muestas, como la abundancia de cada una de ellas.\n\n\n\n\n\n\nNote\n\n\n\nPodemos seleccionar cualquiera de las tres, pero solo en el caso de bacterias. En el caso de los hongos NO podremos seleccionar las distancias UniFrac puesto que al ser ITS2 variable en longitud, no disponemos de un árbol filogenético.\n\n\n\n#Aplicaremos varias funciones del paquete micro4all para poder implementar el test PERMDISP2 y PERMANOVA basándonos en las tres distancias\n# BETADISPERSION\n#¡¡OJO!! Debemos trabajar con los datos normalizados\nbetadisper = Betadispersion(normalized_phyloseq,distances = c(\"bray\", \"unifrac\", \"wunifrac\"), formula = \"status\") \n#argumentos:\n  #-objeto phyloseq normalizado\n  #-distancias a calcular\n  #formula: introducir el nombre de la variable de agrupación\n\nbetadisper[1]# en el elemento 1 de la lista, podemos ver los resultados del test para las tres medidas de disimilitud\n\nNo podemos rechazar la H0 para ninguna de las medidas de disimilitud seleccionadas (p &gt; 0.05), por lo que estamos ante datos homocedásticos. Es genial, puesto que podremos confiar en los resultados del PERMANOVA aunque nuestros datos estén ligeramente desbalanceados.\n\npermanova = Permanova(normalized_phyloseq,distances = c(\"bray\", \"unifrac\", \"wunifrac\"), formula = \"status\") #misma lógica que para la funcion anterior.\n\npermanova[1]\n\nInterpretación: en este caso, tendremos en cuenta varios parámetros del test PERMANOVA, para cada medida de disimilitud:\n-Valor de R2: nos indica el porcentaje de la varianza total que explica nuestra variable de agrupación (estado de los árboles). El resto (residuales) es explicado por factores no medidos en el experimento. En nuestro caso, gracias a la medida Weighted-UniFrac, la condición de los árboles llega a explicar hasta un 64.6% de todas las diferencias reales existentes entre los dos grupos de muestras.\n-p-valor: rechazmos la H0 de igualdad de centroides: vemos que las muestras son significativamente diferentes entre sí en base a cualquiera de las distancias seleccionadas.\nYa hemos detectado diferencias, pero ¿de qué magnitud son estas?\n\n\n\n\n\n\nImportant\n\n\n\nEs importante tener en cuenta que el hecho de que tengamos un pvalor muy bajo y/o un R2 muy alto NO tiene porqué indicar que las diferencias observadas son grandes. El valor de R2 simplemente nos indica cuán responsable es nuestro factor de agrupación de las diferencias que observamos, sean estas pequeñas o grandes. Para obtener información sobre la magnitud de las diferencias, calculamos el tamño del efecto.\n\n\nPara calcular el tamaño del efecto (en estadística multivariante conocido también como partial omega square), debemos seleccionar primero con qué medida de disimilitud vamos a trabajar (no es operativo trabajar con tres medidas si ya tenemos una que explica gran porcentaje de la varianza).\n\n#tenemos que guardar el resultado de nuestro test en una variable.\n#Para ello, guardaremos también el valor de las distancias en una variable:\nwuni=UniFrac(normalized_phyloseq, weighted=T) #calculo de distancias\nadonis_wuni=adonis2(wuni~status, data=mt_pruned, permutations = 9999)#test PERMANOVA con distancia Weighted UniFrac. Permutaciones = iteraciones, cuantas más pongamos, más afinaremos el pvalor real. Por tradición: 9999\n\nadonis_OmegaSq = function(adonisOutput, partial = TRUE){\n  if(!(is(adonisOutput, \"adonis\") || is(adonisOutput, \"anova.cca\")))\n    stop(\"Input should be an adonis object\")\n  if (is(adonisOutput, \"anova.cca\")) {\n    aov_tab &lt;- adonisOutput\n    aov_tab$MeanSqs &lt;- aov_tab$SumOfSqs / aov_tab$Df\n    aov_tab$MeanSqs[length(aov_tab$Df)] &lt;- NA\n  } else {\n    aov_tab &lt;- adonisOutput$aov.tab\n  }\n  heading &lt;- attr(aov_tab, \"heading\")\n  MS_res &lt;- aov_tab[pmatch(\"Residual\", rownames(aov_tab)), \"MeanSqs\"]\n  SS_tot &lt;- aov_tab[rownames(aov_tab) == \"Total\", \"SumsOfSqs\"]\n  N &lt;- aov_tab[rownames(aov_tab) == \"Total\", \"Df\"] + 1\n  if(partial){\n    omega &lt;- apply(aov_tab, 1, function(x) (x[\"Df\"]*(x[\"MeanSqs\"]-MS_res))/(x[\"Df\"]*x[\"MeanSqs\"]+(N-x[\"Df\"])*MS_res))\n    aov_tab$parOmegaSq &lt;- c(omega[1:(length(omega)-2)], NA, NA)\n  } else {\n    omega &lt;- apply(aov_tab, 1, function(x) (x[\"SumsOfSqs\"]-x[\"Df\"]*MS_res)/(SS_tot+MS_res))\n    aov_tab$OmegaSq &lt;- c(omega[1:(length(omega)-2)], NA, NA)\n  }\n  if (is(adonisOutput, \"adonis\"))\n    cn_order &lt;- c(\"Df\", \"SumsOfSqs\", \"MeanSqs\", \"F.Model\", \"R2\",\n                  if (partial) \"parOmegaSq\" else \"OmegaSq\", \"Pr(&gt;F)\")\n  else\n    cn_order &lt;- c(\"Df\", \"SumOfSqs\", \"F\", if (partial) \"parOmegaSq\" else \"OmegaSq\",\n                  \"Pr(&gt;F)\")\n  aov_tab &lt;- aov_tab[, cn_order]\n  attr(aov_tab, \"names\") &lt;- cn_order\n  attr(aov_tab, \"heading\") &lt;- heading\n  if (is(adonisOutput, \"adonis\"))\n    adonisOutput$aov.tab &lt;- aov_tab\n  else\n    adonisOutput &lt;- aov_tab\n  return(adonisOutput)\n}#cargamos esta función, desarrollada por otros usuarios de R\n\nadonis_wuni_eff=adonis_OmegaSq(adonis_wuni)#apliquemos la funcion sobre el PERMANOVA basado exclusivamente en Weighted UniFrac\nadonis_wuni_eff#vemos que es exactamente igual que el objeto 'adonis_wuni', pero incluyendo una columna 'parOmegaSq', que es el término Partial Omega Square, es decir, el tamaño del efecto.\n\nEl valor de omega es &gt; 0.6, por lo podríamos considerar moderado-grande."
  },
  {
    "objectID": "AnalisisBacterias.html#graficos",
    "href": "AnalisisBacterias.html#graficos",
    "title": "Analisis comunidades bacterianas",
    "section": "7.3 Graficos",
    "text": "7.3 Graficos\nPodemos representar las diferencias detectadas en el PERMANOVA, en el espacio multivariante. Para ello, necesitamos calcular gráficos de ordenación, entre ellos:\n-PCoA: Principal Coordinates Analysis o Análisis de coordenadas principales. Similar al PCA pero no está basado en distancias euclídeas. En síntesis, es una forma de distribuir las muestras en N dimensiones, y casi siempre N &gt; 2. La posición de las muestras en el especio estará determinada por vectores y escalares (pesos que tiene cada variable). Obtendremos, entre otros factores, el porcentaje de la varianza que representa cada eje.\n-NMDS: Non-Metric MultiDiomensional Scale o Escalamiento multidimensional no-métrico: en este caso forzamos a que la distribución de las muestras en el espacio sea solamente en dos dimensiones. Puesto que trabajamos con datos multidimensionales, al forzar la distribución solo en dos coordenadas, el algoritmo estará generando un estrés. Se considera que cuando el estrés es &gt; 0.2, el gráfico ya no es representativo de la realidad.\nPara decidir cuál es más adecuado, una buena estrategia es analizar el valor de la varianza explicada por la suma de las dos dimensiones que nos interese considerar, y el valor del estrés del NMDS. Además, es interesante visualizar ambos gráficos, y quedarnos con aquel que resulte en mejores parámetros, y que mejor represente las diferencias observadas.\nCalculemos los parámetros mencionados:\n\n#Calculo del estrés del NMDS:\nNMDS = ordinate(normalized_phyloseq, \"NMDS\", \"wuni\")#calcula la ordenacion. Argumentos: objeto phyloseq normalizado, tipo de ordenacion (PCoA o NMDS, distancia)\nprint(paste(\"The stress of the NMDS based on Weighted UniFrac is:\", NMDS$stress))\n\n#Varianza y multidimensionalidad del PCoA:\nPCOA = ordinate(normalized_phyloseq, \"PCoA\", \"wuni\")\npesos=PCOA$values$Relative_eig[1:2] #varianza explicada por los dos primeros ejes. Podemos indicarle todos los ejes que queramos, teniendo en cuenta que el peso de los ejes estará ordenado de forma descendiente\npesos \n\nsum(PCOA$values$Relative_eig[1:10])#Con esto vemos lo que explican los 10 primeros ejes\nlength(PCOA$values$Relative_eig) #nos dice el número total de dimensiones que necesitaríamos para explicar el 100% de la varianza.\n\nAhora haremos los dos gráficos. Se representa solo uno de ellos, por ejemplo, el PCoA:\n\npcoa = plot_ordination(normalized_phyloseq, PCOA,type= \"samples\", color= \"status\")+#podriamos incluso representar cada grupo de muestras con una forma\n  geom_point(alpha = 4, size = 4.5)+\n  labs(x=paste0(\"Axis 1 (\",round(pesos[1]*100,digits = 2),\"%)\"), \n       y=paste0(\"Axis 2 (\",round(pesos[2]*100,digits = 2),\"%)\"),\n       color=\"status\")+\n  scale_color_manual(values = c(\"healthy\"=\"green\",\"diseased\"=\"black\"),\n                     breaks=c(\"healthy\", \"diseased\"),\n                     labels=c(\"Asymptomatic\", \"Symptomatic\"))+\n  theme_bw()+\n  theme(legend.key=element_blank(),\n        legend.title.align = 0,\n        legend.title = element_text(face=\"bold\",size=18),\n        legend.text.align = 0,\n        axis.text = element_text(size=18),\n        axis.title = element_text(size = 20),\n        plot.title = element_text(hjust=0.5, face=\"bold\",size=18),\n        legend.text = element_text(size = 18))+\n  geom_hline(aes(yintercept = c(0.00)), lty=2, colour=\"grey\")+\n  geom_vline(aes(xintercept = c(0.00)), lty=2, colour=\"grey\")+\n  ggtitle(\"Endosphere\\nPCoA on Weighted-UniFrac distance\")\n\nx11()  \npcoa\n\nEn la Figura 6 podemos observar el resultado. Vemos que, tal y como nos demostró el PERMANOVA, la comunidad bacteriana de árboles sanos y enfermos difiere entre sí\n\n\n\nFigura 6. PCoA basado en distancias Wighted-UniFrac.\n\n\nEjercicio: obtener el gráfico NMDS. Debe tenerse en cuenta que se debe indicar el estrés del mismo.\n\n\n\n\n\n\nNote\n\n\n\nSi se desean obtener todos los gráficos (PCoA, NMDS) basados en todas las distancias, se puede usar el código de micro4all descrito aquí: https://nuriamw.github.io/micro4all/tutorial/package_workflow.html#beta-diversity-analysis"
  },
  {
    "objectID": "AnalisisBacterias.html#obtención-de-abundancia-relativa",
    "href": "AnalisisBacterias.html#obtención-de-abundancia-relativa",
    "title": "Analisis comunidades bacterianas",
    "section": "8.1 Obtención de abundancia relativa",
    "text": "8.1 Obtención de abundancia relativa\nCalculemos la abundancia relativa de todos los ASVs de todas las muestras:\n\nphy_relabun=transform_sample_counts(phy_pruned, function(x){x/sum(x)}*100)"
  },
  {
    "objectID": "AnalisisBacterias.html#aglomeración-al-rango-taxonómico-de-estudio",
    "href": "AnalisisBacterias.html#aglomeración-al-rango-taxonómico-de-estudio",
    "title": "Analisis comunidades bacterianas",
    "section": "8.2 Aglomeración al rango taxonómico de estudio",
    "text": "8.2 Aglomeración al rango taxonómico de estudio\nPero, ¿con qué nivel taxonómico queremos trabajar? La respuesta a esta pregunta depende del diseño experimental y la pregunta científica. Si queremos simplemente hacer un análisis exploratorio, podríamos obtener una visión una visión general analizando los phyla, y una visión detallada analizando los géneros. Por tanto, debemos primero aglomerar los datos al rango taxonómico deseado.\n\n#Phylum\nphylum_relabun=tax_glom(phy_relabun, taxrank = \"Phylum\")#colapsamos el objeto phyloseq al rango indicago\ncolSums(otu_table(phylum_relabun)) #comprobamos que la suma de la abundancia relativa de cada phylum equivale a 100%\n#Género\ngenus_relabun=tax_glom(phy_relabun, taxrank = \"Genus\"); colSums(otu_table(genus_relabun))"
  },
  {
    "objectID": "AnalisisBacterias.html#obtención-de-tablas-exploratorias",
    "href": "AnalisisBacterias.html#obtención-de-tablas-exploratorias",
    "title": "Analisis comunidades bacterianas",
    "section": "8.3 Obtención de tablas exploratorias",
    "text": "8.3 Obtención de tablas exploratorias\nObtengamos una tabla de abundancias relativas, donde tengamos la abundancia de cada taxón en cada grupo de muestras.\nPara los phyla\n\n#Phylum:\nphylum_rel_df=as.data.frame(otu_table(phylum_relabun))#extraemos la tabla de ocurrencias\nphylum_rel_complete=cbind(tax_table(phylum_relabun),phylum_rel_df)#unimos la tabla de taxonomia y la de ocurrencias\nidentical(rownames(phylum_rel_complete),rownames(phylum_rel_df))#comprobamos que sean identicos (tiene uqe salir por consola \"TRUE\")\nwrite.table(data.frame(\"TAXA\"=rownames(phylum_rel_complete),phylum_rel_complete),file=\"abundrel_phylum_porReplicas.txt\", sep=\"\\t\",row.names =F)\n\n\ntable_phylum = t(phylum_rel_df)\ntax_phylum=tax_table(phylum_relabun)\n\nphylum_media=aggregate(table_phylum, \n                            by=list(as.data.frame(sample_data(phylum_relabun))$status), FUN=mean)%&gt;% column_to_rownames(\"Group.1\") %&gt;% t()\n#la funcion 'aggregate' dividide el conjunto de datos tal y como se le indique (aqui, en base al factor de agrupacion 'status'), y computa el estadistico que le indiquemos (aqui, la media primero y luego la desviacion estandar)\n\nphylum_sd = aggregate(table_phylum, \n                           by=list(as.data.frame(sample_data(phylum_relabun))$status), FUN=sd)%&gt;% column_to_rownames(\"Group.1\")  %&gt;% t()  %&gt;%\n  as.data.frame() %&gt;% rename_with(.fn= ~paste0(colnames(phylum_media), \"_SD\"))\n\nphylum_media_sd=merge(tax_phylum, phylum_media, by=0) %&gt;%column_to_rownames(\"Row.names\") %&gt;%\n  merge(phylum_sd, by=0) %&gt;% column_to_rownames(\"Row.names\")\n\nwrite.table(data.frame(\"TAXA\"=rownames(phylum_media_sd),phylum_media_sd), file=\"abundrel_media_sd_phylum.txt\", sep=\"\\t\",row.names =F)\n\nEjercicio: calcular las mismas tablas a nivel de género."
  },
  {
    "objectID": "AnalisisBacterias.html#preparacion-de-datos-para-realizar-los-gráficos",
    "href": "AnalisisBacterias.html#preparacion-de-datos-para-realizar-los-gráficos",
    "title": "Analisis comunidades bacterianas",
    "section": "8.4 Preparacion de datos para realizar los gráficos",
    "text": "8.4 Preparacion de datos para realizar los gráficos\nSe pueden hacer muchos tipos de gráficos, pero nosotros haremos gráficos de barras apiladas. Como en el caso de los géneros podemos tener un número muy grande de categorías, representaremos los mayoritarios (aquellos cuya abundancia se encuentre por encima de un umbral). Este umbral será definido por el usuario. Probemos con un 1%\n\n#para poder utilizar ggplo2, necesitamos que los datos estén 'melted', es decir, organizados en varias columnas: una que incluya el nombre de los phyla, otra que indique el grupo de muestras, y otra que incluya los valores de abundancia\nphylum_data = phylum_media_sd\nphylum_data= phylum_data[,2:9]\nphylum_data=phylum_data[,-(2:6)]\nphylum_media_melt= phylum_data  %&gt;% pivot_longer(!Phylum, names_to=\"status\", values_to=\"Abundance\")                         \n         \n\nunclassified_phylum=phylum_media_melt[phylum_media_melt[,\"Phylum\"] == \"unclassified\",] #retengo los unclassified para no eliminarlos aunque sean &lt;1%\nphylum_media_melt=phylum_media_melt[phylum_media_melt[,\"Phylum\"] != \"unclassified\",] #eliminamos los unclass de la tabla madre para poder meter en el grupo &lt;1% a los minoritarios clasificados\nphylum_media_melt$Phylum[phylum_media_melt$Abundance &lt;= 1.0] = \"Other phyla (&lt;1%)\" #agrupar como \"Other phyla\" todos aquellos que tengan menos de un 1% de abund rel\nphylum_media_melt$Phylum=as.factor(phylum_media_melt$Phylum)#necesitamos que la variable 'Phylum' sea un factor, no de tipo caracter\n\n#en este dataset y para el nivel de Phylum, no tenemos unclassified, por lo que a partir de ahora, no los incluiremos para evitar distorsiones. Se deja el código a disposición, puesto que será útil para el caso de los géneros\n\n#guardamos los \"Other phyla\" en una nueva variable, para poder quitarlos de la tabla original.\nothers_phylum=phylum_media_melt[phylum_media_melt[,\"Phylum\"] == \"Other phyla (&lt;1%)\",]\nphylum_media_melt=phylum_media_melt[phylum_media_melt[,\"Phylum\"] != \"Other phyla (&lt;1%)\",]#los quitamos de la tabla original\n\nordenado_phylum=as.data.frame(phylum_media_melt[order(phylum_media_melt$Abundance, decreasing=T),]) #ordenamos por abundancia relativa\nplot_phylum_input=rbind(ordenado_phylum,others_phylum)#a la tabla ordenada le metemos los \"Other phyla\" (y los \"unclassified\" cuando proceda)\n#es recomendable visualizar cómo ha quedado la tabla, y comporbar la posición de los unclassified (si es que tenemos alguno) y del grupo artificial 'Other phyla'\n\nPreparemos ahora las cuestiones estéticas del gráfico\n\ngroup_label=c(\"Asymptomatic\",\"Symptomatic\")\nbreaks=c(\"healthy\",\"diseased\")\nphyl_name_ordered=as.vector(plot_phylum_input$Phylum)\nnombres_unicos_phylum=unique(phyl_name_ordered)#nos quedamos con los nombres UNICOS, porque hay algunos phyla repetidos (\"Other phyla\")\n\nplot_phylum_input$Phylum=reorder.factor(plot_phylum_input$Phylum,new.order=rev(nombres_unicos_phylum))#ordenamos los phyla como nosotros queremos.\nlab_unicos_phylum=nombres_unicos_phylum #esto es para hacer la leyenda del grafico\n\nsorted_labels_ggplot =sapply(lab_unicos_phylum,\n                                    function(x) if (x == \"Other phyla (&lt;1%)\"|x == \"unclassified\"|x == \"Other genera (&lt;1%)\")\n                                    {parse(text=paste0(\"'\", as.character(x), \"'\"))} else {parse(text = paste0(\"italic('\",as.character(x),\"')\"))}) #esta funcion es para que me ponga en cursiva los nombre de los Phyla pero me deje en redonda los \"Unclassified\" y los \"Other phyla\"\n\n\n#Poner los colores en orden, segun el orden de nombres_unicos. Ej: Proteobacteria (la mas abun) = #0099FF\n#OJO! Tener cuidado  de que hay tantos colores como phyla:\nlength(lab_unicos_phylum)\ncolores_phylum = c(\"#0099FF\",\"#00CC00\",\"magenta\",\"yellow\",\"purple\",\"grey\", \"black\")\n\nlength(lab_unicos_phylum)==length(colores_phylum) #si FALSE, añadir/quitar colores\nlength(lab_unicos_phylum)\nlength(colores_phylum)\n\ntitulo_plot_phylum=\"Endosphere, main phyla\""
  },
  {
    "objectID": "AnalisisBacterias.html#elaboración-del-gráfico",
    "href": "AnalisisBacterias.html#elaboración-del-gráfico",
    "title": "Analisis comunidades bacterianas",
    "section": "8.5. Elaboración del gráfico",
    "text": "8.5. Elaboración del gráfico\n\nphylum_bar=ggplot(plot_phylum_input, aes(x=status, y=Abundance, fill=Phylum, order=Phylum)) + geom_bar(stat=\"identity\", position=\"stack\")+\n  scale_fill_manual(values=colores_phylum,\n                    labels=sorted_labels_ggplot,\n                    breaks=nombres_unicos_phylum)+\n  labs(y=\"Mean relative abundance (%)\", x=NULL, fill=\"Phylum\",title=titulo_plot_phylum)+\n  guides(fill = guide_legend(reverse = TRUE))+#sirve para cambiar el orden de la leyenda\n  scale_x_discrete(limits=breaks,labels=group_label,\n                   breaks=breaks)+\n  #scale_y_continuous(expand=c(0.01,0.01),\n  #                   breaks=c(0,10,20,30,40,50,60,70,80,90,100),\n  #                   labels=c(\"0\",\"10\", \"20\",\"30\",\"40\",\"50\",\"60\",\"70\",\"80\",\"90\",\"100\"),#podemos modificar la escala \n   #                  limits = c(NA, 100))+\n  theme_bw()+\n  theme(panel.border = element_rect(colour=\"black\"))+\n  theme(axis.title.x=element_blank())+\n  theme(plot.title = element_text(face=\"bold\", hjust = 0.5, size=7))+\n  theme(axis.text = element_text(size = 5))+\n  theme(axis.text.x = element_text(face=\"bold\", size=5))+\n  theme(axis.title.y = element_text(size = 7))+\n  theme(legend.key.size = unit(0.2, \"cm\"))+\n  theme(legend.text = element_text(size = 5))+\n  theme(legend.title = element_text(size=7, face=\"bold\"))+\n  theme(legend.title.align=0)+\n  theme(legend.text.align = 0)+#al poner \"expresion\" para poner la cursiva parcial en leyenda, te cambia la alineacion, esto es para que quede alineada a la izda\n  theme(legend.position = \"right\")\n\nx11()\nphylum_bar\nggsave(\"Phylum_barrasapiladas.jpg\", phylum_bar,width = 80, height = 60, units = \"mm\", dpi = 800 )\n\nLa Figura 7 nos revela la altísima abundancia relativa del Phylum Mycoplasmatota en el grupo de muestras relativas a los árboles enfermos\n\n\n\nFigura 7. Distribución de los principales phyla. El grupo artificial ‘Other phyla (&lt;1 %)’ comprende aquellos phyla cuya abundancia promedio es inferior al 1% del total de secuencias\n\n\n¿Os atreveríais a hacer el mismo tipo de gráfico, pero a nivel de género? Nota: tened en cuenta que hay muchos más géneros que phyla, y que cada uno de ellos podría suponer un menor porcentaje de secuencias al ser un rango taxonómico más fino, más detallado. Así pues, es posible que el corte de abundancia de los géneros mayoritarios haya que subirlo, de lo contrario, tendremos muchas categorías (géneros) a colorear y puede ser difícil encontrar muchos colores diferentes y distinguiblees."
  },
  {
    "objectID": "IntroR.html",
    "href": "IntroR.html",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Seleccionando la línea de código a ejecutar o poniendo el cursor en dicha linea, y pulsando el botón run situado en la parte superior derecha del editor.\nPoniendo el curso en la línea a ejecutar y pulsando ctrl + enter\n\n\n\n\nPara poder comentar código, pondremos el símbolo # delante del comentario a realizar. Así pues, todo el texto y símbolos precedidos por # no serán ejecutados. Veamos un ejemplo:\n\n#a=2+32 podemos ver en nuestro Environment que la variable 'a' no se ha creado\nb=2+2 #si corremos esta línea, veremos que la variable b si se ha creado\n\n\n\n\nEn R podemos saber qué comandos hemos ejecutado anteriormente de dos maneras:\n\nSi nos situamos en la consola y le damos al botón ^ de nuestro teclado, podremos ver la orden inmediatamente anterior\n¿otra forma?\n\n\n\n\nEn nuestro directorio de trabajo es donde quedarán todos los archivos que guardemos (si lo hacemos con código).\n\n\n\n\n\n\nImportant\n\n\n\nAntes de empezar a trabajar es MUY IMPORTANTE establecer el directorio de trabajo. Debemos tener cuidado, de lo contrario, podemos trabajar en otro directorio y sobreescribir ficheros, variables, etc.\n\n\nPodemos establecer nuestro lugar de trabajo de dos maneras:\n\nClick en Session (panel superior) &gt; Set working directory &gt; Choose directory, y elegimos la carpeta de trabajo.\nCon el siguiente comando:\n\n\nsetwd(\"C:/Users/radik/Desktop/Curso Microbiota R/CursoMicrobiota\")#setwd(directoriodeinteres)\n\nPara comprobar en qué directorio nos encontramos, lo haremos por código:\n\ngetwd()#no introducimos ningun argumento\n\n\n\n\nDurante el desarrollo de nuestros scripts nos puede resultar útil y necesario visualizar el contenido de los elementos que tenemos en nuestro ambiente.\nSi queremos visualizar los elementos en la pantalla del editor de scripts, lo haremos así\n\nView(b)#podemos visualizar todo tipo de variables\n       #¡OJO! la 'V' tiene que ir en mayuscula; R es sensible a las mayusculas y minusculas\n\nSi queremos visualizar el elemento completo, escribiremos el nombre del elemento directamente en la consola:\n\nb\n\nSi nos enfrentamos a un elemento de gran tamaño (una lista, una tabla con muchas filas), y solo queremos ver el encabezamiento, usaremos este comando:\n\nhead(b)\n\n\n\n\nHabrá ocasiones en las que deseemos conocer información sobre un comando o una función concreta de un paquete (por ejemplo, qué tipo de variables de entrada acepta, cómo funciona, valores de salida, etc.). Para acceder a la documentación de la función concreta, existen varias maneras de proceder:\n\nCon comandos\n\n\n?install.packages() #despues del simbolo '?' escribimos el nombre de la funcion de interes\nhelp(\"install.packages\")#es exactamente lo mismo, nos devuelve la misma información\n\nhelp(package=\"vegan\")#nos proporciona toda la informacion de un paquete de interes (su descripcion, versiones y listado de funciones que incluye)\n\nA continuación se abrirá en el visor inferior derecho, en la pestaña Help toda la información sobre el uso de dicha función\n\nInteractivamente Debemos ir al panel inferior derecho y en la pestaña Help, buscar en la lupa el nombre de nuestra función de interés, tal y como se indica en la Figura 3.\n\n\n\n\nFigura 3. Búsqueda de ayuda en R.\n\n\n\nBuscar en Google u otro buscador la documentación oficial.\n\nToda la información que nos da el comando ? o el panel de ayuda (opciones a y b) está disponible en Google, y en foros de grandísima utilidad como Stack overflow.\n\nInteligencia Artificial\n\nSe desaconseja enormemente el uso de cualquier tipo de inteligencia artificial para búsquedas sencillas que Google u otros buscadores pueden realizar. ¡Ahorremos energía!"
  },
  {
    "objectID": "IntroR.html#para-ejecutar-el-código-escrito-en-el-editor-de-código-podemos-hacerlo-de-dos-maneras",
    "href": "IntroR.html#para-ejecutar-el-código-escrito-en-el-editor-de-código-podemos-hacerlo-de-dos-maneras",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Seleccionando la línea de código a ejecutar o poniendo el cursor en dicha linea, y pulsando el botón run situado en la parte superior derecha del editor.\nPoniendo el curso en la línea a ejecutar y pulsando ctrl + enter"
  },
  {
    "objectID": "IntroR.html#comentar-scripts",
    "href": "IntroR.html#comentar-scripts",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Para poder comentar código, pondremos el símbolo # delante del comentario a realizar. Así pues, todo el texto y símbolos precedidos por # no serán ejecutados. Veamos un ejemplo:\n\n#a=2+32 podemos ver en nuestro Environment que la variable 'a' no se ha creado\nb=2+2 #si corremos esta línea, veremos que la variable b si se ha creado"
  },
  {
    "objectID": "IntroR.html#recuperar-comandos-ejecutados",
    "href": "IntroR.html#recuperar-comandos-ejecutados",
    "title": "Curso Microbiota",
    "section": "",
    "text": "En R podemos saber qué comandos hemos ejecutado anteriormente de dos maneras:\n\nSi nos situamos en la consola y le damos al botón ^ de nuestro teclado, podremos ver la orden inmediatamente anterior\n¿otra forma?"
  },
  {
    "objectID": "IntroR.html#directorio-de-trabajo",
    "href": "IntroR.html#directorio-de-trabajo",
    "title": "Curso Microbiota",
    "section": "",
    "text": "En nuestro directorio de trabajo es donde quedarán todos los archivos que guardemos (si lo hacemos con código).\n\n\n\n\n\n\nImportant\n\n\n\nAntes de empezar a trabajar es MUY IMPORTANTE establecer el directorio de trabajo. Debemos tener cuidado, de lo contrario, podemos trabajar en otro directorio y sobreescribir ficheros, variables, etc.\n\n\nPodemos establecer nuestro lugar de trabajo de dos maneras:\n\nClick en Session (panel superior) &gt; Set working directory &gt; Choose directory, y elegimos la carpeta de trabajo.\nCon el siguiente comando:\n\n\nsetwd(\"C:/Users/radik/Desktop/Curso Microbiota R/CursoMicrobiota\")#setwd(directoriodeinteres)\n\nPara comprobar en qué directorio nos encontramos, lo haremos por código:\n\ngetwd()#no introducimos ningun argumento"
  },
  {
    "objectID": "IntroR.html#visualizar-elementos",
    "href": "IntroR.html#visualizar-elementos",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Durante el desarrollo de nuestros scripts nos puede resultar útil y necesario visualizar el contenido de los elementos que tenemos en nuestro ambiente.\nSi queremos visualizar los elementos en la pantalla del editor de scripts, lo haremos así\n\nView(b)#podemos visualizar todo tipo de variables\n       #¡OJO! la 'V' tiene que ir en mayuscula; R es sensible a las mayusculas y minusculas\n\nSi queremos visualizar el elemento completo, escribiremos el nombre del elemento directamente en la consola:\n\nb\n\nSi nos enfrentamos a un elemento de gran tamaño (una lista, una tabla con muchas filas), y solo queremos ver el encabezamiento, usaremos este comando:\n\nhead(b)"
  },
  {
    "objectID": "IntroR.html#búsqueda-de-ayuda",
    "href": "IntroR.html#búsqueda-de-ayuda",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Habrá ocasiones en las que deseemos conocer información sobre un comando o una función concreta de un paquete (por ejemplo, qué tipo de variables de entrada acepta, cómo funciona, valores de salida, etc.). Para acceder a la documentación de la función concreta, existen varias maneras de proceder:\n\nCon comandos\n\n\n?install.packages() #despues del simbolo '?' escribimos el nombre de la funcion de interes\nhelp(\"install.packages\")#es exactamente lo mismo, nos devuelve la misma información\n\nhelp(package=\"vegan\")#nos proporciona toda la informacion de un paquete de interes (su descripcion, versiones y listado de funciones que incluye)\n\nA continuación se abrirá en el visor inferior derecho, en la pestaña Help toda la información sobre el uso de dicha función\n\nInteractivamente Debemos ir al panel inferior derecho y en la pestaña Help, buscar en la lupa el nombre de nuestra función de interés, tal y como se indica en la Figura 3.\n\n\n\n\nFigura 3. Búsqueda de ayuda en R.\n\n\n\nBuscar en Google u otro buscador la documentación oficial.\n\nToda la información que nos da el comando ? o el panel de ayuda (opciones a y b) está disponible en Google, y en foros de grandísima utilidad como Stack overflow.\n\nInteligencia Artificial\n\nSe desaconseja enormemente el uso de cualquier tipo de inteligencia artificial para búsquedas sencillas que Google u otros buscadores pueden realizar. ¡Ahorremos energía!"
  },
  {
    "objectID": "IntroR.html#numérico-integer-y-entero-integer",
    "href": "IntroR.html#numérico-integer-y-entero-integer",
    "title": "Curso Microbiota",
    "section": "2.1 Numérico (integer) y entero (integer)",
    "text": "2.1 Numérico (integer) y entero (integer)\nEntero: datos numéricos sin parte decimal. Numérico: contienen una parte decimal, fraccionaria\nNo es objeto de este curso repasar las operaciones matemáticas en R, pero se pueden consultar en este link."
  },
  {
    "objectID": "IntroR.html#carácter-character",
    "href": "IntroR.html#carácter-character",
    "title": "Curso Microbiota",
    "section": "2.2 Carácter (character)",
    "text": "2.2 Carácter (character)\nSe encuentran compuestos por letras, números, espacios, signos de puntuación y/o símbolos especiales. También se les conoce como strings.\nAparecen y se indican entrecomillados.\n\n\n\n\n\n\nNote\n\n\n\nUna única cifra (o un conjunto de cifras) pueden ser de tipo carácter. Debemos tener cuidado con esto, ya que podemos querer que R trata a una(s) cifra(s) como carácter, por ejemplo, para que no sea posible aplicar operaciones matemáticas sobre ellas. Puede ser interesante en el caso de tratar los nombres de las muestras en un proyecto de microbiota/bioinformática."
  },
  {
    "objectID": "IntroR.html#factor",
    "href": "IntroR.html#factor",
    "title": "Curso Microbiota",
    "section": "2.3 Factor",
    "text": "2.3 Factor\nSe trata de variables categóricas, es decir, que tienen un número concreto de niveles (levels). Es decir, son clasificadores, variables de agrupación. Un ejemplo: etapa de desarrollo (factor), con 5 niveles: semilla, plántula, joven, adulto, senescente.\n\nNo nos debemos dejar llevar por la apariencia. A simple vista, podemos ver que el contenido de una columna aparenta que se trata de variables de tipo carácter porque están compuestas por letras y/o números, pero puede que se trate de factores. Al fin y al cabo, las variables de tipo factor pueden estar compuestas por caracteres."
  },
  {
    "objectID": "IntroR.html#lógico",
    "href": "IntroR.html#lógico",
    "title": "Curso Microbiota",
    "section": "2.4 Lógico",
    "text": "2.4 Lógico\nSe trata de clases que solo pueden tomar dos valores: TRUE o FALSE, es decir, si cumplen o no una condición. También se conocen como clases booleanas."
  },
  {
    "objectID": "IntroR.html#perdido-y-vacío",
    "href": "IntroR.html#perdido-y-vacío",
    "title": "Curso Microbiota",
    "section": "2.5 Perdido y vacío",
    "text": "2.5 Perdido y vacío\nPerdido (na): se trata de datos perdidos, por ejemplo, datos que no han sido registrados o que han sido omitidos. Son datos faltantes. Se suelen representar como NA.\nVacío (null): representan la ausencia de datos, es decir, un comando nos puede devolver NULL cuando intente recuperar un dato y no lo encuentre (por ejemplo, porque lo hemos borrado)."
  },
  {
    "objectID": "IntroR.html#asignaciones-cambios-de-clase-y-determinación-del-tipo-de-clase",
    "href": "IntroR.html#asignaciones-cambios-de-clase-y-determinación-del-tipo-de-clase",
    "title": "Curso Microbiota",
    "section": "Asignaciones, cambios de clase y determinación del tipo de clase",
    "text": "Asignaciones, cambios de clase y determinación del tipo de clase\nCuando queramos crear una variable y asignarle un valor, usaremos el operador ‘=’ o ‘&lt;-’\n\na = \"hola que tal\" #creo una variable que contiene ese texto\nb &lt;- \"hola que tal\" #idem\n#NOTA: no importa si antes y después de los operadores incluimos un espacio.\n\na==b #¡¡¡OJO!!! Dos simbolos '=' seguidos NO es para realizar una asignacion, sino para preguntarle si los dos elementos son iguales\nidentical(a,b) #a==b es equivalente a identical(a,b)\n\n7==8 #le estamos preguntando si 7 es igual a 8, nos debe devolver FALSE\n7 != 8 #el operador '!=' significa \"diferente de\". En este caso debe devolver TRUE\n\nPara saber de qué clase es nuestro objeto:\n\nclass(a)\nclass(b)\n\nPara determinar o cambiar de clase:\n\na=as.character(\"hola\")\nb=as.factor(\"hola\")\ndesarrollo=factor(c(\"semilla\",\"semilla\",\"plantula\",\"joven\",\"adulto\",\"joven\",\"senescente\"))# 'c' indica que vamos a introducir un vector, donde cada elemento del mismo equivale a un nivel del factor. Lo veremos en el apartado 3.\nlevels(desarrollo)#nos muestra los niveles de un factor\n\n\na=as.integer(2.1+3.2)#vemos que al llamar a la variable 'a' nos devuelve el valor 5\nb=as.numeric(2.1+3.2)#ahora, la variable nos devuelve 5.3\n\nSi quieres conocer más cosas sobre los operadores en R, haz click en [este link] (https://bookdown.org/jboscomendoza/r-principiantes4/operadores.html) donde vienen muchos más detalles."
  },
  {
    "objectID": "IntroR.html#vectores",
    "href": "IntroR.html#vectores",
    "title": "Curso Microbiota",
    "section": "3.1 Vectores",
    "text": "3.1 Vectores"
  },
  {
    "objectID": "IntroR.html#matrices",
    "href": "IntroR.html#matrices",
    "title": "Curso Microbiota",
    "section": "3.2 Matrices",
    "text": "3.2 Matrices"
  },
  {
    "objectID": "IntroR.html#array",
    "href": "IntroR.html#array",
    "title": "Curso Microbiota",
    "section": "Array",
    "text": "Array"
  },
  {
    "objectID": "IntroR.html#dataframes",
    "href": "IntroR.html#dataframes",
    "title": "Curso Microbiota",
    "section": "Dataframes",
    "text": "Dataframes"
  },
  {
    "objectID": "IntroR.html#listas",
    "href": "IntroR.html#listas",
    "title": "Curso Microbiota",
    "section": "Listas",
    "text": "Listas"
  },
  {
    "objectID": "IntroR.html#objetos-phyloseq",
    "href": "IntroR.html#objetos-phyloseq",
    "title": "Curso Microbiota",
    "section": "objetos phyloseq",
    "text": "objetos phyloseq"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "Indice.html",
    "href": "Indice.html",
    "title": "Intro",
    "section": "",
    "text": "1. INTRODUCCIÓN\n¡Bienvenidos al curso “Análisis de microbiomas a partir de lecturas de secuenciación masiva”. En este curso aprenderás aspectos ecológicos teóricos sobre la microbiota asociada a las plantas, tecnologías de secuenciación masiva, así como aspectos técnicos relacionados con el procesamiento de la lecturas obtenidas por secuación masiva con la plataforma Illumina MiSeq, y el análisis estadístico posterior.\nPrácticamente todo el procesamiento y análisis serán realizados con el lenguaje R y en RStudio, por lo que una parte del curso se centrará en aprendizaje del manejo de dichar herramientas.\n\n\n2. CRONOGRAMA ORIENTATIVO\nEl curso seguirá el orden cronológico real de un proyecto de microbiota, por lo que lo hemos dividido tal y como se resume en la Tabla 1.\n\nTabla 1. Organigrama aproximado del curso.\n\n\n\n\n\n\n\nDía\nContenido\nProfesor\n\n\n\n\nDía 1\nIntroducción teórica 1\nManuel Fernández-López\n\n\n\nIntroducción a R y RStudio\nAna V. Lasa\n\n\nDía 2\nIntroducción teórica 2\nManuel Fernández-López\n\n\n\nPrincipales estructuras de datos\nAna V. Lasa\n\n\nDía 3\nProcesamiento de lecturas: DADA2\nAntonio José Fernández-González\n\n\nDía 4\nAnálisis de ecología microbiana\nAna V. Lasa\n\n\nDía 5\nRedes de co-occurrencia\nAntonio José Fernández-González\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa distribución de contenidos de las clases puede verse sujeta a modificaciones de acuerdo al nivel de conocimientos de los alumnos\n\n\n\n\n3. ÍNDICE DE ESTE REPOSITORIO\nEn este repositorio encontrarás información para seguir las clases impartidas por Ana V. Lasa, por lo que está dividido en varias partes:\n-Introducción a R: en esta web se incluyen las directrices para instalar R y RStudio.\n-Principales estructuras de datos: aquí, se explicarán aspectos generales de programación en R, y las diferentes clases y tipos de objetos a emplear durante este curso.\n-Análisis ecológico de comunidades bacterianas: en este apartado describiremos todos los pasos a seguir para analizar diferentes aspectos ecológicos de las comunidades bacterianas.\n-Análisis ecológico de comunidades fúngicas: en este apartado describiremos todos los pasos a seguir para analizar diferentes aspectos ecológicos de las comunidades fúngicas."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Intro",
    "section": "",
    "text": "1. INTRODUCCIÓN\n¡Bienvenidos al curso “Análisis de microbiomas a partir de lecturas de secuenciación masiva”. En este curso aprenderás aspectos ecológicos teóricos sobre la microbiota asociada a las plantas, tecnologías de secuenciación masiva, así como aspectos técnicos relacionados con el procesamiento de la lecturas obtenidas por secuación masiva con la plataforma Illumina MiSeq, y el análisis estadístico posterior.\nPrácticamente todo el procesamiento y análisis serán realizados con el lenguaje R y en RStudio, por lo que una parte del curso se centrará en aprendizaje del manejo de dichar herramientas.\n\n\n2. CRONOGRAMA ORIENTATIVO\nEl curso seguirá el orden cronológico real de un proyecto de microbiota, por lo que lo hemos dividido tal y como se resume en la Tabla 1.\n\nTabla 1. Organigrama aproximado del curso.\n\n\n\n\n\n\n\nDía\nContenido\nProfesor\n\n\n\n\nDía 1\nIntroducción teórica 1\nManuel Fernández-López\n\n\n\nIntroducción a R y RStudio\nAna V. Lasa\n\n\nDía 2\nIntroducción teórica 2\nManuel Fernández-López\n\n\n\nBásico de R y principales estructuras de datos\nAna V. Lasa\n\n\nDía 3\nProcesamiento de lecturas: DADA2\nAntonio José Fernández-González\n\n\nDía 4\nAnálisis de ecología microbiana\nAna V. Lasa\n\n\nDía 5\nRedes de co-occurrencia\nAntonio José Fernández-González\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nLa distribución de contenidos de las clases puede verse sujeta a modificaciones de acuerdo al nivel de conocimientos de los alumnos\n\n\n\n\n3. ÍNDICE DE ESTE REPOSITORIO\nEn este repositorio encontrarás información para seguir las clases impartidas por Ana V. Lasa, por lo que está dividido en varias partes:\n-Introducción a R: en esta web se incluyen las directrices para instalar R y RStudio.\n-Básicos de R y principales estructuras de datos: aquí, se explicarán aspectos generales de programación en R, y las diferentes clases y tipos de objetos a emplear durante este curso.\n-Análisis ecológico de comunidades bacterianas: en este apartado describiremos todos los pasos a seguir para analizar diferentes aspectos ecológicos de las comunidades bacterianas.\n-Análisis ecológico de comunidades fúngicas: en este apartado describiremos todos los pasos a seguir para analizar diferentes aspectos ecológicos de las comunidades fúngicas."
  },
  {
    "objectID": "Instalacion.html",
    "href": "Instalacion.html",
    "title": "Instalación de R y RStudio",
    "section": "",
    "text": "En esta página podrás encontrar las instrucciones para descargarte R y RStudio e instalarlos. Seguiremos la presentación propuesta aquí\nSi no puedes descargar el archivo, prueba a descargártelo desde [SACO] (https://saco.csic.es/f/449179104)"
  },
  {
    "objectID": "Estructuras.html",
    "href": "Estructuras.html",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "Para ejecutar el código escrito en el editor de código, podemos hacerlo de dos maneras:\n\nSeleccionando la línea de código a ejecutar o poniendo el cursor en dicha linea, y pulsando el botón run situado en la parte superior derecha del editor.\nPoniendo el cursor en la línea a ejecutar y pulsando ctrl + enter\n\n\n\n\nPara poder comentar código, pondremos el símbolo # delante del comentario a realizar. Así pues, todo el texto y símbolos precedidos por # no serán ejecutados. Veamos un ejemplo:\n\n#a=2+32 podemos ver en nuestro Environment que la variable 'a' no se ha creado\nb=2+2 #si corremos esta línea, veremos que la variable b si se ha creado\n\n\n\n\nEn R podemos saber qué comandos hemos ejecutado anteriormente de dos maneras:\n\nSi nos situamos en la consola y le damos al botón ^ de nuestro teclado, podremos ver la orden inmediatamente anterior\n¿otra forma?\n\n\n\n\nEn nuestro directorio de trabajo es donde quedarán todos los archivos que guardemos (si lo hacemos con código).\n\n\n\n\n\n\nImportant\n\n\n\nAntes de empezar a trabajar es MUY IMPORTANTE establecer el directorio de trabajo. Debemos tener cuidado, de lo contrario, podemos trabajar en otro directorio y sobreescribir ficheros, variables, etc.\n\n\nPodemos establecer nuestro lugar de trabajo de dos maneras:\n\nClick en Session (panel superior) &gt; Set working directory &gt; Choose directory, y elegimos la carpeta de trabajo.\nCon el siguiente comando:\n\n\nsetwd(\"C:/Users/radik/Desktop/Curso Microbiota R/CursoMicrobiota\")#setwd(directoriodeinteres)\n\nPara comprobar en qué directorio nos encontramos, lo haremos por código:\n\ngetwd()#no introducimos ningun argumento\n\n\n\n\nDurante el desarrollo de nuestros scripts nos puede resultar útil y necesario visualizar el contenido de los elementos que tenemos en nuestro ambiente.\nSi queremos visualizar los elementos en la pantalla del editor de scripts, lo haremos así\n\nView(b)#podemos visualizar todo tipo de variables\n       #¡OJO! la 'V' tiene que ir en mayuscula; R es sensible a las mayusculas y minusculas\n\nSi queremos visualizar el elemento completo, escribiremos el nombre del elemento directamente en la consola:\n\nb\n\nSi nos enfrentamos a un elemento de gran tamaño (una lista, una tabla con muchas filas), y solo queremos ver el encabezamiento, usaremos este comando:\n\nhead(b)\n\nSi queremos solo visualizar el final del elemento, lo haremos con el comando tail(), tal que así:\n\ntail(b)\n\n\n\n\nHabrá ocasiones en las que deseemos conocer información sobre un comando o una función concreta de un paquete (por ejemplo, qué tipo de variables de entrada acepta, cómo funciona, valores de salida, etc.). Para acceder a la documentación de la función concreta, existen varias maneras de proceder:\n\nCon comandos\n\n\n?install.packages() #despues del simbolo '?' escribimos el nombre de la funcion de interes\n\nhelp(\"install.packages\")#es exactamente lo mismo, nos devuelve la misma información\n\nhelp(package=\"vegan\")#nos proporciona toda la informacion de un paquete de interes (su descripcion, versiones y listado de funciones que incluye)\n\nA continuación se abrirá en el visor inferior derecho, en la pestaña Help toda la información sobre el uso de dicha función (Figura 1).\n\n\n\nFigura 1. Búsqueda de ayuda en R con comandos\n\n\n\nInteractivamente Debemos ir al panel inferior derecho y en la pestaña Help, buscar en la lupa el nombre de nuestra función de interés, tal y como se indica en la Figura 2.\n\n\n\n\nFigura 2. Búsqueda de ayuda en R.\n\n\n\nBuscar en Google u otro buscador la documentación oficial.\n\nToda la información que nos da el comando ? o el panel de ayuda (opciones a y b) está disponible en Google, y en foros de grandísima utilidad como Stack overflow.\n\nInteligencia Artificial\n\nSe desaconseja enormemente el uso de cualquier tipo de chatbot para búsquedas sencillas que Google u otros buscadores pueden realizar. ¡Ahorremos energía!"
  },
  {
    "objectID": "Estructuras.html#para-ejecutar-el-código-escrito-en-el-editor-de-código-podemos-hacerlo-de-dos-maneras",
    "href": "Estructuras.html#para-ejecutar-el-código-escrito-en-el-editor-de-código-podemos-hacerlo-de-dos-maneras",
    "title": "Curso Microbiota",
    "section": "",
    "text": "Seleccionando la línea de código a ejecutar o poniendo el cursor en dicha linea, y pulsando el botón run situado en la parte superior derecha del editor.\nPoniendo el curso en la línea a ejecutar y pulsando ctrl + enter"
  },
  {
    "objectID": "Estructuras.html#comentar-scripts",
    "href": "Estructuras.html#comentar-scripts",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "Para poder comentar código, pondremos el símbolo # delante del comentario a realizar. Así pues, todo el texto y símbolos precedidos por # no serán ejecutados. Veamos un ejemplo:\n\n#a=2+32 podemos ver en nuestro Environment que la variable 'a' no se ha creado\nb=2+2 #si corremos esta línea, veremos que la variable b si se ha creado"
  },
  {
    "objectID": "Estructuras.html#recuperar-comandos-ejecutados",
    "href": "Estructuras.html#recuperar-comandos-ejecutados",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "En R podemos saber qué comandos hemos ejecutado anteriormente de dos maneras:\n\nSi nos situamos en la consola y le damos al botón ^ de nuestro teclado, podremos ver la orden inmediatamente anterior\n¿otra forma?"
  },
  {
    "objectID": "Estructuras.html#directorio-de-trabajo",
    "href": "Estructuras.html#directorio-de-trabajo",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "En nuestro directorio de trabajo es donde quedarán todos los archivos que guardemos (si lo hacemos con código).\n\n\n\n\n\n\nImportant\n\n\n\nAntes de empezar a trabajar es MUY IMPORTANTE establecer el directorio de trabajo. Debemos tener cuidado, de lo contrario, podemos trabajar en otro directorio y sobreescribir ficheros, variables, etc.\n\n\nPodemos establecer nuestro lugar de trabajo de dos maneras:\n\nClick en Session (panel superior) &gt; Set working directory &gt; Choose directory, y elegimos la carpeta de trabajo.\nCon el siguiente comando:\n\n\nsetwd(\"C:/Users/radik/Desktop/Curso Microbiota R/CursoMicrobiota\")#setwd(directoriodeinteres)\n\nPara comprobar en qué directorio nos encontramos, lo haremos por código:\n\ngetwd()#no introducimos ningun argumento"
  },
  {
    "objectID": "Estructuras.html#visualizar-elementos",
    "href": "Estructuras.html#visualizar-elementos",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "Durante el desarrollo de nuestros scripts nos puede resultar útil y necesario visualizar el contenido de los elementos que tenemos en nuestro ambiente.\nSi queremos visualizar los elementos en la pantalla del editor de scripts, lo haremos así\n\nView(b)#podemos visualizar todo tipo de variables\n       #¡OJO! la 'V' tiene que ir en mayuscula; R es sensible a las mayusculas y minusculas\n\nSi queremos visualizar el elemento completo, escribiremos el nombre del elemento directamente en la consola:\n\nb\n\nSi nos enfrentamos a un elemento de gran tamaño (una lista, una tabla con muchas filas), y solo queremos ver el encabezamiento, usaremos este comando:\n\nhead(b)\n\nSi queremos solo visualizar el final del elemento, lo haremos con el comando tail(), tal que así:\n\ntail(b)"
  },
  {
    "objectID": "Estructuras.html#búsqueda-de-ayuda",
    "href": "Estructuras.html#búsqueda-de-ayuda",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "Habrá ocasiones en las que deseemos conocer información sobre un comando o una función concreta de un paquete (por ejemplo, qué tipo de variables de entrada acepta, cómo funciona, valores de salida, etc.). Para acceder a la documentación de la función concreta, existen varias maneras de proceder:\n\nCon comandos\n\n\n?install.packages() #despues del simbolo '?' escribimos el nombre de la funcion de interes\n\nhelp(\"install.packages\")#es exactamente lo mismo, nos devuelve la misma información\n\nhelp(package=\"vegan\")#nos proporciona toda la informacion de un paquete de interes (su descripcion, versiones y listado de funciones que incluye)\n\nA continuación se abrirá en el visor inferior derecho, en la pestaña Help toda la información sobre el uso de dicha función (Figura 1).\n\n\n\nFigura 1. Búsqueda de ayuda en R con comandos\n\n\n\nInteractivamente Debemos ir al panel inferior derecho y en la pestaña Help, buscar en la lupa el nombre de nuestra función de interés, tal y como se indica en la Figura 2.\n\n\n\n\nFigura 2. Búsqueda de ayuda en R.\n\n\n\nBuscar en Google u otro buscador la documentación oficial.\n\nToda la información que nos da el comando ? o el panel de ayuda (opciones a y b) está disponible en Google, y en foros de grandísima utilidad como Stack overflow.\n\nInteligencia Artificial\n\nSe desaconseja enormemente el uso de cualquier tipo de chatbot para búsquedas sencillas que Google u otros buscadores pueden realizar. ¡Ahorremos energía!"
  },
  {
    "objectID": "Estructuras.html#numérico-integer-y-entero-integer",
    "href": "Estructuras.html#numérico-integer-y-entero-integer",
    "title": "Principios básicos y estructuras de datos",
    "section": "2.1 Numérico (integer) y entero (integer)",
    "text": "2.1 Numérico (integer) y entero (integer)\nEntero: datos numéricos sin parte decimal. Numérico: contienen una parte decimal, fraccionaria\nNo es objeto de este curso repasar las operaciones matemáticas en R, pero se pueden consultar en este link."
  },
  {
    "objectID": "Estructuras.html#carácter-character",
    "href": "Estructuras.html#carácter-character",
    "title": "Principios básicos y estructuras de datos",
    "section": "2.2 Carácter (character)",
    "text": "2.2 Carácter (character)\nSe encuentran compuestos por letras, números, espacios, signos de puntuación y/o símbolos especiales. A las cadenas de caracteres se les conoce como strings.\nAparecen y se indican entrecomillados.\n\n\n\n\n\n\nNote\n\n\n\nUna única cifra (o un conjunto de cifras) pueden ser de tipo carácter. Debemos tener cuidado con esto, ya que podemos querer que R trate a una(s) cifra(s) como carácter(es), por ejemplo, para que no sea posible aplicar operaciones matemáticas sobre ellas. Puede ser interesante en el caso de tratar los nombres de las muestras en un proyecto de microbiota/bioinformática."
  },
  {
    "objectID": "Estructuras.html#factor",
    "href": "Estructuras.html#factor",
    "title": "Principios básicos y estructuras de datos",
    "section": "2.3 Factor",
    "text": "2.3 Factor\nSe trata de variables categóricas, es decir, que tienen un número concreto de niveles (levels). Es decir, son clasificadores, variables de agrupación. Un ejemplo: etapa de desarrollo (factor), con 5 niveles: semilla, plántula, joven, adulto, senescente.\n\nNo nos debemos dejar llevar por la apariencia. A simple vista, podemos ver que el contenido de una columna aparenta que se trata de variables de tipo carácter porque están compuestas por letras y/o números, pero puede que se trate de factores. Al fin y al cabo, las variables de tipo factor pueden estar compuestas por caracteres."
  },
  {
    "objectID": "Estructuras.html#lógico",
    "href": "Estructuras.html#lógico",
    "title": "Principios básicos y estructuras de datos",
    "section": "2.4 Lógico",
    "text": "2.4 Lógico\nSe trata de clases que solo pueden tomar dos valores: TRUE o FALSE, es decir, si cumplen o no una condición. También se conocen como clases booleanas."
  },
  {
    "objectID": "Estructuras.html#perdido-y-vacío",
    "href": "Estructuras.html#perdido-y-vacío",
    "title": "Principios básicos y estructuras de datos",
    "section": "2.5 Perdido y vacío",
    "text": "2.5 Perdido y vacío\nPerdido (na): se trata de datos perdidos, por ejemplo, datos que no han sido registrados o que han sido omitidos. Son datos faltantes. Se suelen representar como NA.\nVacío (null): representan la ausencia de datos, es decir, un comando nos puede devolver NULL cuando intente recuperar un dato y no lo encuentre (por ejemplo, porque lo hemos borrado)."
  },
  {
    "objectID": "Estructuras.html#asignaciones-cambios-de-clase-y-determinación-del-tipo-de-clase",
    "href": "Estructuras.html#asignaciones-cambios-de-clase-y-determinación-del-tipo-de-clase",
    "title": "Principios básicos y estructuras de datos",
    "section": "Asignaciones, cambios de clase y determinación del tipo de clase",
    "text": "Asignaciones, cambios de clase y determinación del tipo de clase\nCuando queramos crear una variable y asignarle un valor, usaremos el operador ‘=’ o ‘&lt;-’\n\na = \"hola que tal\" #creo una variable que contiene ese texto\nb &lt;- \"hola que tal\" #idem\n#NOTA: no importa si antes y después de los operadores incluimos un espacio.\n\na==b #¡¡¡OJO!!! Dos simbolos '=' seguidos NO es para realizar una asignacion, sino para preguntarle si los dos elementos son iguales\nidentical(a,b) #a==b es equivalente a identical(a,b)\n\n7==8 #le estamos preguntando si 7 es igual a 8, nos debe devolver FALSE\n7 != 8 #el operador '!=' significa \"diferente de\". En este caso debe devolver TRUE\n\nPara saber de qué clase es nuestro objeto:\n\nclass(a)\nclass(b)\n\nPara determinar o cambiar de clase:\n\na=as.character(\"hola\")\nb=as.factor(\"hola\")\ndesarrollo=factor(c(\"semilla\",\"semilla\",\"plantula\",\"joven\",\"adulto\",\"joven\",\"senescente\"))# 'c' indica que vamos a introducir un vector, donde cada elemento del mismo equivale a un nivel del factor. Lo veremos en el apartado 3.\nlevels(desarrollo)#nos muestra los niveles de un factor\n\n\na=as.integer(2.1+3.2)#vemos que al llamar a la variable 'a' nos devuelve el valor 5\nb=as.numeric(2.1+3.2)#ahora, la variable nos devuelve 5.3\n\nSi quieres conocer más cosas sobre los operadores en R, haz click en [este link] (https://bookdown.org/jboscomendoza/r-principiantes4/operadores.html) donde vienen muchos más detalles."
  },
  {
    "objectID": "Estructuras.html#vectores",
    "href": "Estructuras.html#vectores",
    "title": "Principios básicos y estructuras de datos",
    "section": "3.1 Vectores",
    "text": "3.1 Vectores\nSe trata de una colección de elementos o conjunto de datos del mismo tipo o clase. Es la estructura mínima de R.\nPara crearlos, debemos preceder a la lista de elementos del vector la letra c, y los elementos tienen que estar entrecomillados:\n\ncompra = c(\"pan\", \"harina\", \"pollo\")\nclass(compra)\n\nprecios=c(\"1.50\",\"3.75\",\"6.98\")\n\nmixto=c(\"7.4\",\"hola\")\nclass(mixto)#OJO! el valor 7.4 lo toma como carácter, pues todos los elementos han de ser del mismo tipo/clase\n\nboo=c(TRUE,FALSE,FALSE)#como no están entrecomillados, los toma como booleano\nclass(boo)\n\nno_boo=c(\"TRUE\",\"FALSE\",\"FALSE\")\nis.vector(no_boo)#es para preguntarle directamente si es un vector\n\nPara saber de forma rápida y visual de qué tipo son mis vectores, basta con buscarlos en el panel de Environment, tal y como se aprecia en la Figura 5:\n\n\n\nFigura 5. Apariencia de Environment.\n\n\nPodemos fusionar vectores, incluso de diferentes tipos. R de forma automática realizará una coerción, una fusión de los mismos. R determina automáticamente la clase resultante, que será la más universal (generalmente, caracter). Comprobémoslo:\n\nprecios_compra=c(precios,compra)\nclass(precios_compra)\nprecios_compra #coloca uno inmediatamente después del otro.\n\n\n3.1.1 Operaciones con vectores\n\nPodemos conocer la longitud de los vectores:\n\n\nlength(precios_compra) #longitud: 6\n\n\nConocer el elemento que ocupa una posición del vector. Basta con poner la posición entre corchetes, tras el nombre del vector\n\n\nprecios_compra[2] #que acceda al elemento en la posición 2\n\n\nModificar un vector. Debemos asignar el nuevo valor a la posición que queremos modificar:\n\n\n#queremos cambiar el segundo precio, por 0.49:\nprecios_compra[2]=\"0.49\"\nprecios_compra #comprobamos todo el contenido del vector\nprecios_compra[2] #comprobamos el contenido en la posición 2\n\n#añadir elementos a un vector (añadir también es 'modificar' un vector)\nprecios_compra[7]= \"gelducha\"\nprecios_compra\n\n\nPreguntas al vector\n\nPodemos interaccionar con los vectores, y preguntarles si un elemento es igual, mayor, menos que otro valor; cuál es la cifra máxima y mínima de un vector numérico, entre otras.\n\nprecios[3] &gt;  6.97\nwhich.max(precios) #NO nos devuelve el valor máximo, sino la POSICIÓN que ocupa el valor máximo\n\n#Ejercicio: escribe en UNA sola línea de código el valor máximo del 'precios'"
  },
  {
    "objectID": "Estructuras.html#matrices",
    "href": "Estructuras.html#matrices",
    "title": "Principios básicos y estructuras de datos",
    "section": "3.2 Matrices",
    "text": "3.2 Matrices"
  },
  {
    "objectID": "Estructuras.html#array",
    "href": "Estructuras.html#array",
    "title": "Principios básicos y estructuras de datos",
    "section": "Array",
    "text": "Array"
  },
  {
    "objectID": "Estructuras.html#dataframes",
    "href": "Estructuras.html#dataframes",
    "title": "Principios básicos y estructuras de datos",
    "section": "Dataframes",
    "text": "Dataframes"
  },
  {
    "objectID": "Estructuras.html#listas",
    "href": "Estructuras.html#listas",
    "title": "Principios básicos y estructuras de datos",
    "section": "Listas",
    "text": "Listas"
  },
  {
    "objectID": "Estructuras.html#objetos-phyloseq",
    "href": "Estructuras.html#objetos-phyloseq",
    "title": "Principios básicos y estructuras de datos",
    "section": "objetos phyloseq",
    "text": "objetos phyloseq"
  },
  {
    "objectID": "Estructuras.html#ejecución-de-código",
    "href": "Estructuras.html#ejecución-de-código",
    "title": "Principios básicos y estructuras de datos",
    "section": "",
    "text": "Para ejecutar el código escrito en el editor de código, podemos hacerlo de dos maneras:\n\nSeleccionando la línea de código a ejecutar o poniendo el cursor en dicha linea, y pulsando el botón run situado en la parte superior derecha del editor.\nPoniendo el cursor en la línea a ejecutar y pulsando ctrl + enter"
  }
]